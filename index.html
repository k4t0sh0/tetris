<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>HTML Tetris with Line Clear Effect</title>
  <style>
    :root{--cell:28px}
    body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; display:flex; gap:20px; align-items:flex-start; padding:20px; background:#08101a;}
    canvas{background:#0b1220; image-rendering:pixelated; border-radius:6px}
    #ui{min-width:220px}
    .panel{background:#0f1720; color:#e6eef8; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.5)}
    h1{font-size:18px; margin:0 0 8px}
    .small{font-size:13px; opacity:.95}
    .grid{display:grid; gap:8px}
    .label{font-size:12px; color:#9fb0c8}
    button{padding:8px 10px; border-radius:8px; border:0; background:#1f6feb; color:white; cursor:pointer}
    #boardContainer{display:flex; gap:12px; align-items:flex-start;}
    .hint{font-size:12px; color:#9fb0c8; margin-top:8px}
  </style>
</head>
<body>
  <div id="boardContainer">
    <canvas id="board" width="10" height="20" style="width:calc(var(--cell)*10);height:calc(var(--cell)*20)"></canvas>
    <div id="ui">
      <div class="panel">
        <h1>HTML テトリス（7-Bag）</h1>
        <div class="small grid">
          <div><span class="label">スコア</span><div id="score">0</div></div>
          <div><span class="label">レベル</span><div id="level">1</div></div>
          <div><span class="label">次のピース</span><canvas id="next" width="4" height="4" style="width:calc(var(--cell)*4);height:calc(var(--cell)*4);"></canvas></div>
          <div><span class="label">ホールド</span><canvas id="hold" width="4" height="4" style="width:calc(var(--cell)*4);height:calc(var(--cell)*4);"></canvas></div>
          <div style="display:flex; gap:8px;"><button id="start">スタート / リスタート</button> <button id="pause">一時停止</button></div>
          <div class="hint">操作: ← → move, ↓ soft drop, ↑ rotate, Space hard drop, C hold</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------- 定数 / 初期設定 ---------- */
const COLS = 10, ROWS = 20;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
canvas.width = COLS; canvas.height = ROWS;

const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold');
const hctx = holdCanvas.getContext('2d');

const TETROMINOES = {
  I: {color:'#5ce1ff', blocks:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]},
  J: {color:'#3b82f6', blocks:[[1,0,0],[1,1,1],[0,0,0]]},
  L: {color:'#f97316', blocks:[[0,0,1],[1,1,1],[0,0,0]]},
  O: {color:'#facc15', blocks:[[1,1],[1,1]]},
  S: {color:'#10b981', blocks:[[0,1,1],[1,1,0],[0,0,0]]},
  T: {color:'#a78bfa', blocks:[[0,1,0],[1,1,1],[0,0,0]]},
  Z: {color:'#ef4444', blocks:[[1,1,0],[0,1,1],[0,0,0]]}
};
const NAMES = Object.keys(TETROMINOES);

let board, current, nextPiece, holdPiece = null, canHold = true, bag = [];
let score=0, level=1, dropInterval=1000, dropCounter=0, isRunning=false, isPaused=false, isAnimating=false;
let clearingRows = []; // アニメーション中に消す行のインデックス
let clearAnimStart = 0, clearAnimDur = 400; // ms

/* ---------- ヘルパー ---------- */
function createBoard(){ board = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }

function refillBag(){
  bag = NAMES.slice();
  for(let i=bag.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [bag[i],bag[j]]=[bag[j],bag[i]];
  }
}
function nextPieceFromBag(){
  if(bag.length===0) refillBag();
  const name = bag.pop();
  const def = TETROMINOES[name];
  const mat = def.blocks.map(r=>r.slice());
  return {name,mat,x:Math.floor((COLS-mat[0].length)/2),y:-(mat.length-1),color:def.color};
}

function rotate(matrix){
  const N=matrix.length;
  const res=Array.from({length:N},()=>Array(N).fill(0));
  for(let r=0;r<N;r++)for(let c=0;c<N;c++)res[c][N-1-r]=matrix[r][c];
  return trimMatrix(res);
}
function trimMatrix(mat){
  let top=0,bottom=mat.length-1,left=0,right=mat[0].length-1;
  while(top<=bottom && mat[top].every(v=>!v)) top++;
  while(bottom>=top && mat[bottom].every(v=>!v)) bottom--;
  while(left<=right && mat.every(row=>!row[left])) left++;
  while(right>=left && mat.every(row=>!row[right])) right--;
  if(top>bottom||left>right) return [[0]];
  const out=[];for(let r=top;r<=bottom;r++) out.push(mat[r].slice(left,right+1));
  return out;
}

function pad(mat){
  const N=Math.max(mat.length,mat[0].length);
  const out=Array.from({length:N},()=>Array(N).fill(0));
  const rOff=Math.floor((N-mat.length)/2),cOff=Math.floor((N-mat[0].length)/2);
  for(let r=0;r<mat.length;r++)for(let c=0;c<mat[r].length;c++)out[r+rOff][c+cOff]=mat[r][c];
  return out;
}

/* ---------- 物理判定 / マージ ---------- */
function collide(board,piece,ox=0,oy=0){
  const m=piece.mat;
  for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++){
    if(m[r][c]){
      const x=piece.x+c+ox, y=piece.y+r+oy;
      if(x<0||x>=COLS||y>=ROWS) return true;
      if(y>=0 && board[y][x]) return true;
    }
  }
  return false;
}
function merge(board,piece){
  const m=piece.mat;
  for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++)if(m[r][c]){
    const x=piece.x+c,y=piece.y+r;
    if(y>=0) board[y][x]=piece.color;
  }
}

/* ---------- ゴースト ---------- */
function ghostY(){
  const clone = {...current, mat: current.mat.map(r=>r.slice()), x: current.x, y: current.y};
  while(!collide(board, clone, 0, 1)) clone.y++;
  return clone.y;
}

/* ---------- 行消去（アニメーション対応） ---------- */
function sweepPrepare(){
  // 消える行のインデックスを収集（bottom → top）
  const rows=[];
  for(let r=0;r<ROWS;r++){
    if(board[r].every(c=>c)) rows.push(r);
  }
  return rows;
}
function startLineClear(rows){
  if(rows.length===0) return false;
  clearingRows = rows.slice(); // 保存
  clearAnimStart = performance.now();
  isAnimating = true;
  return true;
}
function finishLineClear(){
  // 実際の削除（上に詰める）
  // rows は昇順（小→大）でも大丈夫だが安定のため降順で削除
  clearingRows.sort((a,b)=>b-a);
  for(const r of clearingRows){
    board.splice(r,1);
    board.unshift(Array(COLS).fill(0));
  }
  // スコア計算
  const lines = clearingRows.length;
  const points = lines===1?100:lines===2?300:lines===3?500:lines===4?800:lines*200;
  score += points * level;
  level = Math.floor(score/1000)+1;
  dropInterval = Math.max(50, 1000 / (1.18 ** level)); // レベルが上がるほど早くなる
  updateUI();
  clearingRows = [];
  isAnimating = false;
}

/* ---------- 出現 / ロック ---------- */
function spawn(){
  current = nextPiece || nextPieceFromBag();
  nextPiece = nextPieceFromBag();
  current.x = Math.floor((COLS-current.mat[0].length)/2);
  current.y = -(current.mat.length-1);
  canHold = true;
  if(collide(board,current,0,0)){
    stop();
    setTimeout(()=>alert('ゲームオーバー\nスコア: '+score),10);
  }
}

function lockPiece(){
  merge(board,current);
  // アニメーション準備
  const rows = sweepPrepare();
  if(rows.length>0){
    startLineClear(rows);
    // アニメ中はspawnしない。finishLineClearの後 spawn() を行う。
  } else {
    spawn();
  }
}

function hardDrop(){ while(!collide(board,current,0,1)) current.y++; lockPiece(); }
function softDrop(){ if(!collide(board,current,0,1)) current.y++; else { lockPiece(); } }
function move(dx){ if(!collide(board,current,dx,0)) current.x+=dx; }

function rotateCurrent(){
  const cloned = {...current, mat: rotate(pad(current.mat))};
  const kicks = [0,-1,1,-2,2];
  for(const k of kicks){
    if(!collide(board, cloned, k, 0)){
      current.mat = cloned.mat;
      current.x += k;
      return;
    }
  }
}

/* ---------- ホールド ---------- */
function hold(){
  if(!canHold || isAnimating) return;
  if(!holdPiece){
    holdPiece = { ...current, mat: current.mat.map(r=>r.slice()) };
    spawn();
  } else {
    const temp = holdPiece;
    holdPiece = { ...current, mat: current.mat.map(r=>r.slice()) };
    current = { ...temp, mat: temp.mat.map(r=>r.slice()), x: Math.floor((COLS-temp.mat[0].length)/2), y: -(temp.mat.length-1) };
    if(collide(board,current,0,0)) current = nextPieceFromBag();
  }
  canHold = false;
}

/* ---------- 描画 ---------- */
function drawCell(x,y,color,context){
  context.fillStyle = color || '#222';
  context.fillRect(x,y,1,1);
  context.strokeStyle = 'rgba(0,0,0,.25)';
  context.lineWidth = 0.03;
  context.strokeRect(x+0.02,y+0.02,0.96,0.96);
}
function draw(){
  // メインボード
  ctx.clearRect(0,0,COLS,ROWS);
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    drawCell(c,r, board[r][c] || '#071019', ctx);
  }

  // ラインクリアのアニメーション（点滅／フェード）
  if(isAnimating && clearingRows.length>0){
    const t = performance.now();
    const progress = Math.min(1, (t - clearAnimStart) / clearAnimDur);
    // 点滅（フェード）: 0->1 の間で明るさ変化
    const flashAlpha = 0.15 + Math.abs(Math.sin(progress * Math.PI * 3)) * 0.85;
    for(const r of clearingRows){
      for(let c=0;c<COLS;c++){
        ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
        ctx.fillRect(c, r, 1, 1);
      }
    }
    // 終了時処理
    if(progress >= 1) {
      finishLineClear();
      spawn();
    }
  }

  // ゴースト
  if(current){
    const gy = ghostY();
    for(let r=0;r<current.mat.length;r++)for(let c=0;c<current.mat[r].length;c++) if(current.mat[r][c]){
      const x=current.x+c, y=current.y+r;
      const yGhost = gy + r;
      if(yGhost>=0) drawCell(x, yGhost, 'rgba(255,255,255,0.08)', ctx);
    }
  }

  // カレントピース
  if(current){
    for(let r=0;r<current.mat.length;r++)for(let c=0;c<current.mat[r].length;c++) if(current.mat[r][c]){
      const x=current.x+c, y=current.y+r;
      if(y>=0) drawCell(x,y,current.color,ctx);
    }
  }

  // next / hold
  nctx.clearRect(0,0,4,4);
  if(nextPiece){
    const m=nextPiece.mat, offX=Math.floor((4-m[0].length)/2), offY=Math.floor((4-m.length)/2);
    for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++) if(m[r][c]) drawCell(c+offX, r+offY, nextPiece.color, nctx);
  }
  hctx.clearRect(0,0,4,4);
  if(holdPiece){
    const m=holdPiece.mat, offX=Math.floor((4-m[0].length)/2), offY=Math.floor((4-m.length)/2);
    for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++) if(m[r][c]) drawCell(c+offX, r+offY, holdPiece.color, hctx);
  }
}

/* ---------- UI 更新 ---------- */
function updateUI(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
}

/* ---------- メインループ ---------- */
let lastTime=0;
function dropTick(delta){
  if(!isRunning || isPaused || isAnimating) return;
  dropCounter += delta;
  if(dropCounter >= dropInterval){
    dropCounter = 0;
    // 自然落下
    if(!collide(board,current,0,1)) current.y++;
    else lockPiece();
  }
}
function loop(time=0){
  const delta = time - lastTime;
  lastTime = time;
  dropTick(delta);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- 入力 ---------- */
window.addEventListener('keydown',e=>{
  // ゲーム内キーはスクロールを防止
  if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','Space','KeyC'].includes(e.code)) e.preventDefault();
  if(!isRunning || isAnimating) return;

  if(e.code==='ArrowLeft') move(-1);
  else if(e.code==='ArrowRight') move(1);
  else if(e.code==='ArrowDown') softDrop();
  else if(e.code==='ArrowUp') rotateCurrent();   // ← 上で回転
  else if(e.code==='Space') hardDrop();          // ← スペースでハード
  else if(e.code==='KeyC') hold();
});

/* ---------- スタート / ポーズ ---------- */
function start(){
  createBoard();
  score = 0; level = 1; dropInterval = 1000;
  dropCounter = 0;
  updateUI();
  refillBag();
  nextPiece = nextPieceFromBag();
  spawn();
  isRunning = true;
  isPaused = false;
  isAnimating = false;
}
function stop(){ isRunning = false; isPaused = false; isAnimating = false; }
function togglePause(){ if(!isRunning) return; isPaused = !isPaused; document.getElementById('pause').textContent = isPaused ? '再開' : '一時停止'; }

/* ---------- ボタン ---------- */
document.getElementById('start').addEventListener('click', ()=>{ start(); });
document.getElementById('pause').addEventListener('click', ()=>{ togglePause(); });

/* ---------- 初期起動 ---------- */
start();
requestAnimationFrame(loop);
</script>
</body>
</html>
